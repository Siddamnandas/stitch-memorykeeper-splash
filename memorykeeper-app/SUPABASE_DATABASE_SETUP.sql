-- Create profiles table
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  full_name text,
  avatar_url text,
  memory_strength integer default 0,
  constraint username_length check (char_length(full_name) >= 3)
);

-- Track which family members can view a profile
create table profile_family_access (
  id bigint generated by default as identity primary key,
  profile_id uuid references profiles (id) on delete cascade not null,
  approved_user_id uuid references auth.users not null,
  relationship text,
  approved_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique (profile_id, approved_user_id)
);

-- Create memories table
create table memories (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references auth.users on delete cascade not null,
  prompt text not null,
  response text not null,
  date date not null,
  type text not null,
  tags text[] default array[]::text[],
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Audit log for sensitive changes
create table audit_logs (
  id bigint generated by default as identity primary key,
  table_name text not null,
  record_id uuid,
  action text not null,
  actor_uid uuid,
  changed_data jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Set up Row Level Security (RLS)
alter table profiles enable row level security;
alter table memories enable row level security;
alter table profile_family_access enable row level security;
alter table audit_logs enable row level security;

-- Create policies
create policy "Profiles viewable by owner or approved family" on profiles
  for select using (
    auth.uid() = id
    or exists (
      select 1
      from profile_family_access pfa
      where pfa.profile_id = profiles.id
        and pfa.approved_user_id = auth.uid()
    )
  );

create policy "Users can insert their own profile." on profiles
  for insert with check (auth.uid() = id);

create policy "Users can update own profile." on profiles
  for update using (auth.uid() = id);

create policy "Owners manage family access" on profile_family_access
  for all using (auth.uid() = profile_id)
  with check (auth.uid() = profile_id);

create policy "Service role can read audit logs" on audit_logs
  for select using (
    coalesce(current_setting('request.jwt.claim.role', true), '') = 'service_role'
  );

create policy "Users can view their own memories." on memories
  for select using (auth.uid() = user_id);

create policy "Users can insert their own memories." on memories
  for insert with check (auth.uid() = user_id);

create policy "Users can update their own memories." on memories
  for update using (auth.uid() = user_id);

create policy "Users can delete their own memories." on memories
  for delete using (auth.uid() = user_id);

-- Audit trigger helper
create or replace function record_audit_change()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  actor_id uuid;
begin
  begin
    actor_id := nullif(current_setting('request.jwt.claim.sub', true), '')::uuid;
  exception when others then
    actor_id := null;
  end;

  insert into audit_logs (table_name, record_id, action, actor_uid, changed_data)
  values (
    TG_TABLE_NAME,
    coalesce(
      (case when TG_OP = 'DELETE' then OLD.id else NEW.id end),
      gen_random_uuid()
    ),
    TG_OP,
    actor_id,
    case
      when TG_OP = 'DELETE' then to_jsonb(OLD)
      else to_jsonb(NEW)
    end
  );

  if TG_OP = 'DELETE' then
    return OLD;
  end if;
  return NEW;
end;
$$;

create trigger profiles_audit_trigger
  after insert or update or delete on profiles
  for each row execute procedure record_audit_change();

create trigger memories_audit_trigger
  after insert or update or delete on memories
  for each row execute procedure record_audit_change();
