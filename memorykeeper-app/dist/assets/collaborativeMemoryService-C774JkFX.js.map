{"version":3,"file":"collaborativeMemoryService-C774JkFX.js","sources":["../../src/lib/collaborativeMemoryService.ts"],"sourcesContent":["import { supabase } from './supabaseClient';\n\n// Type for safe Supabase client\ntype SafeSupabaseClient = NonNullable<typeof supabase>;\nimport { getMemories, Memory } from './dataService';\nimport { addActivityAndRecalculate } from './memoryStrengthService';\nimport { sanitizeTextInput } from './inputSanitizer';\n\nexport interface SharedMemory {\n  id: string;\n  original_memory_id: string;\n  owner_id: string;\n  shared_with_user_id: string;\n  permission_level: 'view' | 'edit' | 'admin';\n  shared_at: string;\n  expires_at?: string;\n  is_active: boolean;\n}\n\nexport interface MemoryShare {\n  id: string;\n  memory_id: string;\n  shared_by_user_id: string;\n  shared_with_user_ids: string[];\n  permission_level: 'view' | 'edit';\n  message?: string;\n  expires_at?: string;\n  created_at: string;\n}\n\nexport interface CollaborativeMemory {\n  id: string;\n  title: string;\n  description?: string;\n  owner_id: string;\n  collaborators: string[];\n  permissions: Record<string, 'view' | 'edit' | 'admin'>;\n  shared_memories: string[];\n  is_public: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface CollaborationInvite {\n  id: string;\n  collection_id: string;\n  invited_by_user_id: string;\n  invited_user_email: string;\n  invited_user_id?: string;\n  permission_level: 'view' | 'edit';\n  status: 'pending' | 'accepted' | 'declined' | 'expired';\n  message?: string;\n  expires_at: string;\n  created_at: string;\n}\n\n/**\n * Share a memory with another user\n */\nexport const shareMemoryWithUser = async (\n  memoryId: string,\n  sharedWithUserId: string,\n  permissionLevel: 'view' | 'edit' = 'view',\n  message?: string,\n  expiresAt?: Date\n): Promise<{ success: boolean; shareId?: string; error?: string }> => {\n  if (!supabase) {\n    return { success: false, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { data: user } = await (supabase as SafeSupabaseClient).auth.getUser();\n    if (!user.user) throw new Error('User not authenticated');\n\n    // Check if memory exists and user owns it\n    const { data: memories } = await getMemories(user.user.id);\n    const memory = memories?.find(m => m.id === memoryId);\n    if (!memory) throw new Error('Memory not found or access denied');\n\n    // Create share record\n    const shareData = {\n      memory_id: memoryId,\n      shared_by_user_id: user.user.id,\n      shared_with_user_ids: [sharedWithUserId],\n      permission_level: permissionLevel,\n      message: message ? sanitizeTextInput(message) : undefined,\n      expires_at: expiresAt?.toISOString(),\n      created_at: new Date().toISOString()\n    };\n\n    const { data, error } = await (supabase as SafeSupabaseClient)\n      .from('memory_shares')\n      .insert([shareData])\n      .select()\n      .single();\n\n    if (error) throw error;\n\n    // Update memory strength for sharing activity\n    await addActivityAndRecalculate(user.user.id, {\n      type: 'memory_shared',\n      timestamp: new Date(),\n      value: 8,\n      metadata: { memoryId }\n    });\n\n    return { success: true, shareId: data.id };\n  } catch (error: any) {\n    console.error('Error sharing memory:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n/**\n * Get memories shared with the current user\n */\nexport const getSharedMemoriesWithMe = async (\n  userId: string\n): Promise<{ data: any[] | null; error: any }> => {\n  if (!supabase) {\n    return { data: null, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { data, error } = await (supabase as SafeSupabaseClient)\n      .from('memory_shares')\n      .select(`\n        id,\n        memory_id,\n        shared_by_user_id,\n        permission_level,\n        message,\n        created_at,\n        expires_at,\n        memories (\n          id,\n          prompt,\n          response,\n          date,\n          type,\n          tags,\n          user_id\n        ),\n        profiles!memory_shares_shared_by_user_id_fkey (\n          full_name,\n          avatar_url\n        )\n      `)\n      .eq('shared_with_user_ids', userId)\n      .eq('is_active', true)\n      .is('expires_at', null)\n      .or(`expires_at.is.null,expires_at.gt.${new Date().toISOString()}`);\n\n    return { data, error };\n  } catch (error) {\n    console.error('Error fetching shared memories:', error);\n    return { data: null, error };\n  }\n};\n\n/**\n * Get memories shared by the current user\n */\nexport const getMemoriesSharedByMe = async (\n  userId: string\n): Promise<{ data: any[] | null; error: any }> => {\n  if (!supabase) {\n    return { data: null, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { data, error } = await (supabase as SafeSupabaseClient)\n      .from('memory_shares')\n      .select(`\n        id,\n        memory_id,\n        shared_with_user_ids,\n        permission_level,\n        message,\n        created_at,\n        expires_at,\n        memories (\n          id,\n          prompt,\n          response,\n          date,\n          type,\n          tags\n        )\n      `)\n      .eq('shared_by_user_id', userId)\n      .eq('is_active', true);\n\n    return { data, error };\n  } catch (error) {\n    console.error('Error fetching shared memories:', error);\n    return { data: null, error };\n  }\n};\n\n/**\n * Retrieve specific memories by their IDs\n */\nexport const getMemoriesByIds = async (\n  memoryIds: string[]\n): Promise<{ data: Memory[]; error: any }> => {\n  if (!supabase) {\n    return { data: [], error: 'Supabase not configured' };\n  }\n\n  if (memoryIds.length === 0) {\n    return { data: [], error: null };\n  }\n\n  try {\n    const { data, error } = await (supabase as SafeSupabaseClient)\n      .from('memories')\n      .select('*')\n      .in('id', memoryIds);\n\n    return { data: data ?? [], error };\n  } catch (error) {\n    console.error('Error fetching memories by IDs:', error);\n    return { data: [], error };\n  }\n};\n\n/**\n * Create a collaborative memory collection\n */\nexport const createCollaborativeCollection = async (\n  title: string,\n  description?: string,\n  isPublic: boolean = false\n): Promise<{ success: boolean; collectionId?: string; error?: string }> => {\n  if (!supabase) {\n    return { success: false, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { data: user } = await (supabase as SafeSupabaseClient).auth.getUser();\n    if (!user.user) throw new Error('User not authenticated');\n\n    const collectionData = {\n      title: sanitizeTextInput(title),\n      description: description ? sanitizeTextInput(description) : undefined,\n      owner_id: user.user.id,\n      collaborators: [user.user.id],\n      permissions: { [user.user.id]: 'admin' },\n      shared_memories: [],\n      is_public: isPublic,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n\n    const { data, error } = await (supabase as SafeSupabaseClient)\n      .from('collaborative_collections')\n      .insert([collectionData])\n      .select()\n      .single();\n\n    if (error) throw error;\n\n    return { success: true, collectionId: data.id };\n  } catch (error: any) {\n    console.error('Error creating collaborative collection:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n/**\n * Invite user to collaborative collection\n */\nexport const inviteUserToCollection = async (\n  collectionId: string,\n  email: string,\n  permissionLevel: 'view' | 'edit' = 'view',\n  message?: string\n): Promise<{ success: boolean; inviteId?: string; error?: string }> => {\n  if (!supabase) {\n    return { success: false, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { data: user } = await (supabase as SafeSupabaseClient).auth.getUser();\n    if (!user.user) throw new Error('User not authenticated');\n\n    // Check if user has admin permission for this collection\n    const { data: collection } = await (supabase as SafeSupabaseClient)\n      .from('collaborative_collections')\n      .select('permissions')\n      .eq('id', collectionId)\n      .eq('owner_id', user.user.id)\n      .single();\n\n    if (!collection || collection.permissions[user.user.id] !== 'admin') {\n      throw new Error('Insufficient permissions to invite users');\n    }\n\n    // Find user by email\n    const { data: invitedUser } = await (supabase as SafeSupabaseClient)\n      .from('profiles')\n      .select('id')\n      .eq('email', email.toLowerCase())\n      .single();\n\n    const expiresAt = new Date();\n    expiresAt.setDate(expiresAt.getDate() + 7); // 7 day expiry\n\n    const inviteData = {\n      collection_id: collectionId,\n      invited_by_user_id: user.user.id,\n      invited_user_email: email.toLowerCase(),\n      invited_user_id: invitedUser?.id,\n      permission_level: permissionLevel,\n      status: 'pending',\n      message: message ? sanitizeTextInput(message) : undefined,\n      expires_at: expiresAt.toISOString(),\n      created_at: new Date().toISOString()\n    };\n\n    const { data, error } = await (supabase as SafeSupabaseClient)\n      .from('collaboration_invites')\n      .insert([inviteData])\n      .select()\n      .single();\n\n    if (error) throw error;\n\n    return { success: true, inviteId: data.id };\n  } catch (error: any) {\n    console.error('Error inviting user to collection:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n/**\n * Accept collaboration invite\n */\nexport const acceptCollaborationInvite = async (\n  inviteId: string\n): Promise<{ success: boolean; error?: string }> => {\n  if (!supabase) {\n    return { success: false, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { data: user } = await (supabase as SafeSupabaseClient).auth.getUser();\n    if (!user.user) throw new Error('User not authenticated');\n\n    // Get invite details\n    const { data: invite } = await (supabase as SafeSupabaseClient)\n      .from('collaboration_invites')\n      .select('collection_id, permission_level, invited_user_id')\n      .eq('id', inviteId)\n      .eq('invited_user_id', user.user.id)\n      .eq('status', 'pending')\n      .single();\n\n    if (!invite) throw new Error('Invite not found or already processed');\n\n    // Update invite status\n    await (supabase as SafeSupabaseClient)\n      .from('collaboration_invites')\n      .update({ status: 'accepted' })\n      .eq('id', inviteId);\n\n    // Add user to collection collaborators\n    const { data: collection } = await (supabase as SafeSupabaseClient)\n      .from('collaborative_collections')\n      .select('collaborators, permissions')\n      .eq('id', invite.collection_id)\n      .single();\n\n    if (collection) {\n      const updatedCollaborators = [...collection.collaborators, user.user.id];\n      const updatedPermissions = {\n        ...collection.permissions,\n        [user.user.id]: invite.permission_level\n      };\n\n      await (supabase as SafeSupabaseClient)\n        .from('collaborative_collections')\n        .update({\n          collaborators: updatedCollaborators,\n          permissions: updatedPermissions,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', invite.collection_id);\n    }\n\n    return { success: true };\n  } catch (error: any) {\n    console.error('Error accepting collaboration invite:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n/**\n * Fetch invites created by the current user\n */\nexport const getInvitesSentByUser = async (\n  userId: string\n): Promise<{ data: CollaborationInvite[] | null; error: any }> => {\n  if (!supabase) {\n    return { data: null, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { data, error } = await (supabase as SafeSupabaseClient)\n      .from('collaboration_invites')\n      .select(`\n        id,\n        collection_id,\n        invited_by_user_id,\n        invited_user_email,\n        invited_user_id,\n        permission_level,\n        status,\n        message,\n        expires_at,\n        created_at,\n        collaborative_collections (\n          title\n        ),\n        inviter:profiles!collaboration_invites_invited_by_user_id_fkey (\n          full_name,\n          avatar_url\n        )\n      `)\n      .eq('invited_by_user_id', userId)\n      .order('created_at', { ascending: false });\n\n    return { data, error };\n  } catch (error) {\n    console.error('Error fetching invites sent by user:', error);\n    return { data: null, error };\n  }\n};\n\n/**\n * Fetch invites where the user (or their email) is the recipient\n */\nexport const getInvitesForUser = async (\n  userId: string,\n  email: string\n): Promise<{ data: CollaborationInvite[] | null; error: any }> => {\n  if (!supabase) {\n    return { data: null, error: 'Supabase not configured' };\n  }\n\n  try {\n    const lowerEmail = email?.toLowerCase?.() ?? '';\n    const now = new Date().toISOString();\n\n    const filters: string[] = [];\n    if (userId) filters.push(`invited_user_id.eq.${userId}`);\n    if (lowerEmail) filters.push(`invited_user_email.eq.${lowerEmail}`);\n\n    if (filters.length === 0) {\n      return { data: [], error: null };\n    }\n\n    const { data, error } = await (supabase as SafeSupabaseClient)\n      .from('collaboration_invites')\n      .select(`\n        id,\n        collection_id,\n        invited_by_user_id,\n        invited_user_email,\n        invited_user_id,\n        permission_level,\n        status,\n        message,\n        expires_at,\n        created_at,\n        collaborative_collections (\n          title\n        ),\n        inviter:profiles!collaboration_invites_invited_by_user_id_fkey (\n          full_name,\n          avatar_url\n        )\n      `)\n      .or(filters.join(','))\n      .eq('status', 'pending')\n      .gte('expires_at', now)\n      .order('created_at', { ascending: false });\n\n    return { data, error };\n  } catch (error) {\n    console.error('Error fetching invites for user:', error);\n    return { data: null, error };\n  }\n};\n\n/**\n * Decline collaboration invite\n */\nexport const declineCollaborationInvite = async (\n  inviteId: string\n): Promise<{ success: boolean; error?: string }> => {\n  if (!supabase) {\n    return { success: false, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { error } = await (supabase as SafeSupabaseClient)\n      .from('collaboration_invites')\n      .update({ status: 'declined' })\n      .eq('id', inviteId);\n\n    if (error) throw error;\n\n    return { success: true };\n  } catch (error: any) {\n    console.error('Error declining collaboration invite:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n/**\n * Get user's collaborative collections\n */\nexport const getUserCollaborativeCollections = async (\n  userId: string\n): Promise<{ data: any[] | null; error: any }> => {\n  if (!supabase) {\n    return { data: null, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { data, error } = await (supabase as SafeSupabaseClient)\n      .from('collaborative_collections')\n      .select(`\n        id,\n        title,\n        description,\n        owner_id,\n        collaborators,\n        permissions,\n        shared_memories,\n        is_public,\n        created_at,\n        updated_at,\n        profiles!collaborative_collections_owner_id_fkey (\n          full_name,\n          avatar_url\n        )\n      `)\n      .contains('collaborators', [userId])\n      .order('updated_at', { ascending: false });\n\n    return { data, error };\n  } catch (error) {\n    console.error('Error fetching collaborative collections:', error);\n    return { data: null, error };\n  }\n};\n\n/**\n * Add memory to collaborative collection\n */\nexport const addMemoryToCollection = async (\n  collectionId: string,\n  memoryId: string\n): Promise<{ success: boolean; error?: string }> => {\n  if (!supabase) {\n    return { success: false, error: 'Supabase not configured' };\n  }\n\n  try {\n    const { data: user } = await (supabase as SafeSupabaseClient).auth.getUser();\n    if (!user.user) throw new Error('User not authenticated');\n\n    // Check permissions\n    const { data: collection } = await (supabase as SafeSupabaseClient)\n      .from('collaborative_collections')\n      .select('permissions, shared_memories')\n      .eq('id', collectionId)\n      .single();\n\n    const userPermission = collection?.permissions[user.user.id];\n    if (!userPermission || userPermission === 'view') {\n      throw new Error('Insufficient permissions to add memories');\n    }\n\n    // Add memory to collection\n    const updatedMemories = [...(collection?.shared_memories || []), memoryId];\n\n    const { error } = await (supabase as SafeSupabaseClient)\n      .from('collaborative_collections')\n      .update({\n        shared_memories: updatedMemories,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', collectionId);\n\n    if (error) throw error;\n\n    return { success: true };\n  } catch (error: any) {\n    console.error('Error adding memory to collection:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n// Export service object\nexport const collaborativeMemoryService = {\n  shareMemoryWithUser,\n  getSharedMemoriesWithMe,\n  getMemoriesSharedByMe,\n  createCollaborativeCollection,\n  inviteUserToCollection,\n  acceptCollaborationInvite,\n  declineCollaborationInvite,\n  getUserCollaborativeCollections,\n  addMemoryToCollection,\n  getMemoriesByIds,\n  getInvitesSentByUser,\n  getInvitesForUser\n};\n"],"names":["shareMemoryWithUser","memoryId","sharedWithUserId","permissionLevel","message","expiresAt","supabase","user","memories","getMemories","shareData","sanitizeTextInput","data","error","addActivityAndRecalculate","getSharedMemoriesWithMe","userId","getMemoriesSharedByMe","getMemoriesByIds","memoryIds","createCollaborativeCollection","title","description","isPublic","collectionData","inviteUserToCollection","collectionId","email","collection","invitedUser","inviteData","acceptCollaborationInvite","inviteId","invite","updatedCollaborators","updatedPermissions","getInvitesSentByUser","getInvitesForUser","lowerEmail","_a","now","filters","declineCollaborationInvite","getUserCollaborativeCollections","addMemoryToCollection","userPermission","updatedMemories","collaborativeMemoryService"],"mappings":"wGA2DO,MAAMA,EAAsB,MACjCC,EACAC,EACAC,EAAmC,OACnCC,EACAC,IACoE,CACpE,GAAI,CAACC,EACH,MAAO,CAAE,QAAS,GAAO,MAAO,yBAAA,EAGlC,GAAI,CACF,KAAM,CAAE,KAAMC,CAAA,EAAS,MAAOD,EAAgC,KAAK,QAAA,EACnE,GAAI,CAACC,EAAK,KAAM,MAAM,IAAI,MAAM,wBAAwB,EAGxD,KAAM,CAAE,KAAMC,CAAA,EAAa,MAAMC,EAAYF,EAAK,KAAK,EAAE,EAEzD,GAAI,EADWC,GAAA,YAAAA,EAAU,KAAK,GAAK,EAAE,KAAOP,IAC/B,MAAM,IAAI,MAAM,mCAAmC,EAGhE,MAAMS,EAAY,CAChB,UAAWT,EACX,kBAAmBM,EAAK,KAAK,GAC7B,qBAAsB,CAACL,CAAgB,EACvC,iBAAkBC,EAClB,QAASC,EAAUO,EAAkBP,CAAO,EAAI,OAChD,WAAYC,GAAA,YAAAA,EAAW,cACvB,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,EAG/B,CAAE,KAAAO,EAAM,MAAAC,CAAA,EAAU,MAAOP,EAC5B,KAAK,eAAe,EACpB,OAAO,CAACI,CAAS,CAAC,EAClB,OAAA,EACA,OAAA,EAEH,GAAIG,EAAO,MAAMA,EAGjB,aAAMC,EAA0BP,EAAK,KAAK,GAAI,CAC5C,KAAM,gBACN,cAAe,KACf,MAAO,EACP,SAAU,CAAE,SAAAN,CAAA,CAAS,CACtB,EAEM,CAAE,QAAS,GAAM,QAASW,EAAK,EAAA,CACxC,OAASC,EAAY,CACnB,eAAQ,MAAM,wBAAyBA,CAAK,EACrC,CAAE,QAAS,GAAO,MAAOA,EAAM,OAAA,CACxC,CACF,EAKaE,EAA0B,MACrCC,GACgD,CAChD,GAAI,CAACV,EACH,MAAO,CAAE,KAAM,KAAM,MAAO,yBAAA,EAG9B,GAAI,CACF,KAAM,CAAE,KAAAM,EAAM,MAAAC,GAAU,MAAOP,EAC5B,KAAK,eAAe,EACpB,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAqBP,EACA,GAAG,uBAAwBU,CAAM,EACjC,GAAG,YAAa,EAAI,EACpB,GAAG,aAAc,IAAI,EACrB,GAAG,oCAAoC,IAAI,OAAO,YAAA,CAAa,EAAE,EAEpE,MAAO,CAAE,KAAAJ,EAAM,MAAAC,CAAA,CACjB,OAASA,EAAO,CACd,eAAQ,MAAM,kCAAmCA,CAAK,EAC/C,CAAE,KAAM,KAAM,MAAAA,CAAA,CACvB,CACF,EAKaI,EAAwB,MACnCD,GACgD,CAChD,GAAI,CAACV,EACH,MAAO,CAAE,KAAM,KAAM,MAAO,yBAAA,EAG9B,GAAI,CACF,KAAM,CAAE,KAAAM,EAAM,MAAAC,GAAU,MAAOP,EAC5B,KAAK,eAAe,EACpB,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAgBP,EACA,GAAG,oBAAqBU,CAAM,EAC9B,GAAG,YAAa,EAAI,EAEvB,MAAO,CAAE,KAAAJ,EAAM,MAAAC,CAAA,CACjB,OAASA,EAAO,CACd,eAAQ,MAAM,kCAAmCA,CAAK,EAC/C,CAAE,KAAM,KAAM,MAAAA,CAAA,CACvB,CACF,EAKaK,EAAmB,MAC9BC,GAC4C,CAC5C,GAAI,CAACb,EACH,MAAO,CAAE,KAAM,GAAI,MAAO,yBAAA,EAG5B,GAAIa,EAAU,SAAW,EACvB,MAAO,CAAE,KAAM,GAAI,MAAO,IAAA,EAG5B,GAAI,CACF,KAAM,CAAE,KAAAP,EAAM,MAAAC,GAAU,MAAOP,EAC5B,KAAK,UAAU,EACf,OAAO,GAAG,EACV,GAAG,KAAMa,CAAS,EAErB,MAAO,CAAE,KAAMP,GAAQ,CAAA,EAAI,MAAAC,CAAA,CAC7B,OAASA,EAAO,CACd,eAAQ,MAAM,kCAAmCA,CAAK,EAC/C,CAAE,KAAM,CAAA,EAAI,MAAAA,CAAA,CACrB,CACF,EAKaO,EAAgC,MAC3CC,EACAC,EACAC,EAAoB,KACqD,CACzE,GAAI,CAACjB,EACH,MAAO,CAAE,QAAS,GAAO,MAAO,yBAAA,EAGlC,GAAI,CACF,KAAM,CAAE,KAAMC,CAAA,EAAS,MAAOD,EAAgC,KAAK,QAAA,EACnE,GAAI,CAACC,EAAK,KAAM,MAAM,IAAI,MAAM,wBAAwB,EAExD,MAAMiB,EAAiB,CACrB,MAAOb,EAAkBU,CAAK,EAC9B,YAAaC,EAAcX,EAAkBW,CAAW,EAAI,OAC5D,SAAUf,EAAK,KAAK,GACpB,cAAe,CAACA,EAAK,KAAK,EAAE,EAC5B,YAAa,CAAE,CAACA,EAAK,KAAK,EAAE,EAAG,OAAA,EAC/B,gBAAiB,CAAA,EACjB,UAAWgB,EACX,WAAY,IAAI,KAAA,EAAO,YAAA,EACvB,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,EAG/B,CAAE,KAAAX,EAAM,MAAAC,CAAA,EAAU,MAAOP,EAC5B,KAAK,2BAA2B,EAChC,OAAO,CAACkB,CAAc,CAAC,EACvB,OAAA,EACA,OAAA,EAEH,GAAIX,EAAO,MAAMA,EAEjB,MAAO,CAAE,QAAS,GAAM,aAAcD,EAAK,EAAA,CAC7C,OAASC,EAAY,CACnB,eAAQ,MAAM,2CAA4CA,CAAK,EACxD,CAAE,QAAS,GAAO,MAAOA,EAAM,OAAA,CACxC,CACF,EAKaY,EAAyB,MACpCC,EACAC,EACAxB,EAAmC,OACnCC,IACqE,CACrE,GAAI,CAACE,EACH,MAAO,CAAE,QAAS,GAAO,MAAO,yBAAA,EAGlC,GAAI,CACF,KAAM,CAAE,KAAMC,CAAA,EAAS,MAAOD,EAAgC,KAAK,QAAA,EACnE,GAAI,CAACC,EAAK,KAAM,MAAM,IAAI,MAAM,wBAAwB,EAGxD,KAAM,CAAE,KAAMqB,GAAe,MAAOtB,EACjC,KAAK,2BAA2B,EAChC,OAAO,aAAa,EACpB,GAAG,KAAMoB,CAAY,EACrB,GAAG,WAAYnB,EAAK,KAAK,EAAE,EAC3B,OAAA,EAEH,GAAI,CAACqB,GAAcA,EAAW,YAAYrB,EAAK,KAAK,EAAE,IAAM,QAC1D,MAAM,IAAI,MAAM,0CAA0C,EAI5D,KAAM,CAAE,KAAMsB,CAAA,EAAgB,MAAOvB,EAClC,KAAK,UAAU,EACf,OAAO,IAAI,EACX,GAAG,QAASqB,EAAM,YAAA,CAAa,EAC/B,OAAA,EAEGtB,MAAgB,KACtBA,EAAU,QAAQA,EAAU,QAAA,EAAY,CAAC,EAEzC,MAAMyB,EAAa,CACjB,cAAeJ,EACf,mBAAoBnB,EAAK,KAAK,GAC9B,mBAAoBoB,EAAM,YAAA,EAC1B,gBAAiBE,GAAA,YAAAA,EAAa,GAC9B,iBAAkB1B,EAClB,OAAQ,UACR,QAASC,EAAUO,EAAkBP,CAAO,EAAI,OAChD,WAAYC,EAAU,YAAA,EACtB,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,EAG/B,CAAE,KAAAO,EAAM,MAAAC,CAAA,EAAU,MAAOP,EAC5B,KAAK,uBAAuB,EAC5B,OAAO,CAACwB,CAAU,CAAC,EACnB,OAAA,EACA,OAAA,EAEH,GAAIjB,EAAO,MAAMA,EAEjB,MAAO,CAAE,QAAS,GAAM,SAAUD,EAAK,EAAA,CACzC,OAASC,EAAY,CACnB,eAAQ,MAAM,qCAAsCA,CAAK,EAClD,CAAE,QAAS,GAAO,MAAOA,EAAM,OAAA,CACxC,CACF,EAKakB,EAA4B,MACvCC,GACkD,CAClD,GAAI,CAAC1B,EACH,MAAO,CAAE,QAAS,GAAO,MAAO,yBAAA,EAGlC,GAAI,CACF,KAAM,CAAE,KAAMC,CAAA,EAAS,MAAOD,EAAgC,KAAK,QAAA,EACnE,GAAI,CAACC,EAAK,KAAM,MAAM,IAAI,MAAM,wBAAwB,EAGxD,KAAM,CAAE,KAAM0B,CAAA,EAAW,MAAO3B,EAC7B,KAAK,uBAAuB,EAC5B,OAAO,kDAAkD,EACzD,GAAG,KAAM0B,CAAQ,EACjB,GAAG,kBAAmBzB,EAAK,KAAK,EAAE,EAClC,GAAG,SAAU,SAAS,EACtB,OAAA,EAEH,GAAI,CAAC0B,EAAQ,MAAM,IAAI,MAAM,uCAAuC,EAGpE,MAAO3B,EACJ,KAAK,uBAAuB,EAC5B,OAAO,CAAE,OAAQ,WAAY,EAC7B,GAAG,KAAM0B,CAAQ,EAGpB,KAAM,CAAE,KAAMJ,CAAA,EAAe,MAAOtB,EACjC,KAAK,2BAA2B,EAChC,OAAO,4BAA4B,EACnC,GAAG,KAAM2B,EAAO,aAAa,EAC7B,OAAA,EAEH,GAAIL,EAAY,CACd,MAAMM,EAAuB,CAAC,GAAGN,EAAW,cAAerB,EAAK,KAAK,EAAE,EACjE4B,EAAqB,CACzB,GAAGP,EAAW,YACd,CAACrB,EAAK,KAAK,EAAE,EAAG0B,EAAO,gBAAA,EAGzB,MAAO3B,EACJ,KAAK,2BAA2B,EAChC,OAAO,CACN,cAAe4B,EACf,YAAaC,EACb,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,EACA,GAAG,KAAMF,EAAO,aAAa,CAClC,CAEA,MAAO,CAAE,QAAS,EAAA,CACpB,OAASpB,EAAY,CACnB,eAAQ,MAAM,wCAAyCA,CAAK,EACrD,CAAE,QAAS,GAAO,MAAOA,EAAM,OAAA,CACxC,CACF,EAKauB,EAAuB,MAClCpB,GACgE,CAChE,GAAI,CAACV,EACH,MAAO,CAAE,KAAM,KAAM,MAAO,yBAAA,EAG9B,GAAI,CACF,KAAM,CAAE,KAAAM,EAAM,MAAAC,GAAU,MAAOP,EAC5B,KAAK,uBAAuB,EAC5B,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAkBP,EACA,GAAG,qBAAsBU,CAAM,EAC/B,MAAM,aAAc,CAAE,UAAW,GAAO,EAE3C,MAAO,CAAE,KAAAJ,EAAM,MAAAC,CAAA,CACjB,OAASA,EAAO,CACd,eAAQ,MAAM,uCAAwCA,CAAK,EACpD,CAAE,KAAM,KAAM,MAAAA,CAAA,CACvB,CACF,EAKawB,EAAoB,MAC/BrB,EACAW,IACgE,OAChE,GAAI,CAACrB,EACH,MAAO,CAAE,KAAM,KAAM,MAAO,yBAAA,EAG9B,GAAI,CACF,MAAMgC,IAAaC,EAAAZ,GAAA,YAAAA,EAAO,cAAP,YAAAY,EAAA,KAAAZ,KAA0B,GACvCa,EAAM,IAAI,KAAA,EAAO,YAAA,EAEjBC,EAAoB,CAAA,EAI1B,GAHIzB,GAAQyB,EAAQ,KAAK,sBAAsBzB,CAAM,EAAE,EACnDsB,GAAYG,EAAQ,KAAK,yBAAyBH,CAAU,EAAE,EAE9DG,EAAQ,SAAW,EACrB,MAAO,CAAE,KAAM,GAAI,MAAO,IAAA,EAG5B,KAAM,CAAE,KAAA7B,EAAM,MAAAC,GAAU,MAAOP,EAC5B,KAAK,uBAAuB,EAC5B,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAkBP,EACA,GAAGmC,EAAQ,KAAK,GAAG,CAAC,EACpB,GAAG,SAAU,SAAS,EACtB,IAAI,aAAcD,CAAG,EACrB,MAAM,aAAc,CAAE,UAAW,GAAO,EAE3C,MAAO,CAAE,KAAA5B,EAAM,MAAAC,CAAA,CACjB,OAASA,EAAO,CACd,eAAQ,MAAM,mCAAoCA,CAAK,EAChD,CAAE,KAAM,KAAM,MAAAA,CAAA,CACvB,CACF,EAKa6B,EAA6B,MACxCV,GACkD,CAClD,GAAI,CAAC1B,EACH,MAAO,CAAE,QAAS,GAAO,MAAO,yBAAA,EAGlC,GAAI,CACF,KAAM,CAAE,MAAAO,CAAA,EAAU,MAAOP,EACtB,KAAK,uBAAuB,EAC5B,OAAO,CAAE,OAAQ,UAAA,CAAY,EAC7B,GAAG,KAAM0B,CAAQ,EAEpB,GAAInB,EAAO,MAAMA,EAEjB,MAAO,CAAE,QAAS,EAAA,CACpB,OAASA,EAAY,CACnB,eAAQ,MAAM,wCAAyCA,CAAK,EACrD,CAAE,QAAS,GAAO,MAAOA,EAAM,OAAA,CACxC,CACF,EAKa8B,EAAkC,MAC7C3B,GACgD,CAChD,GAAI,CAACV,EACH,MAAO,CAAE,KAAM,KAAM,MAAO,yBAAA,EAG9B,GAAI,CACF,KAAM,CAAE,KAAAM,EAAM,MAAAC,GAAU,MAAOP,EAC5B,KAAK,2BAA2B,EAChC,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAeP,EACA,SAAS,gBAAiB,CAACU,CAAM,CAAC,EAClC,MAAM,aAAc,CAAE,UAAW,EAAA,CAAO,EAE3C,MAAO,CAAE,KAAAJ,EAAM,MAAAC,CAAA,CACjB,OAASA,EAAO,CACd,eAAQ,MAAM,4CAA6CA,CAAK,EACzD,CAAE,KAAM,KAAM,MAAAA,CAAA,CACvB,CACF,EAKa+B,EAAwB,MACnClB,EACAzB,IACkD,CAClD,GAAI,CAACK,EACH,MAAO,CAAE,QAAS,GAAO,MAAO,yBAAA,EAGlC,GAAI,CACF,KAAM,CAAE,KAAMC,CAAA,EAAS,MAAOD,EAAgC,KAAK,QAAA,EACnE,GAAI,CAACC,EAAK,KAAM,MAAM,IAAI,MAAM,wBAAwB,EAGxD,KAAM,CAAE,KAAMqB,CAAA,EAAe,MAAOtB,EACjC,KAAK,2BAA2B,EAChC,OAAO,8BAA8B,EACrC,GAAG,KAAMoB,CAAY,EACrB,OAAA,EAEGmB,EAAiBjB,GAAA,YAAAA,EAAY,YAAYrB,EAAK,KAAK,IACzD,GAAI,CAACsC,GAAkBA,IAAmB,OACxC,MAAM,IAAI,MAAM,0CAA0C,EAI5D,MAAMC,EAAkB,CAAC,IAAIlB,GAAA,YAAAA,EAAY,kBAAmB,CAAA,EAAK3B,CAAQ,EAEnE,CAAE,MAAAY,GAAU,MAAOP,EACtB,KAAK,2BAA2B,EAChC,OAAO,CACN,gBAAiBwC,EACjB,WAAY,IAAI,KAAA,EAAO,YAAA,CAAY,CACpC,EACA,GAAG,KAAMpB,CAAY,EAExB,GAAIb,EAAO,MAAMA,EAEjB,MAAO,CAAE,QAAS,EAAA,CACpB,OAASA,EAAY,CACnB,eAAQ,MAAM,qCAAsCA,CAAK,EAClD,CAAE,QAAS,GAAO,MAAOA,EAAM,OAAA,CACxC,CACF,EAGakC,EAA6B,CACxC,oBAAA/C,EACA,wBAAAe,EACA,sBAAAE,EACA,8BAAAG,EACA,uBAAAK,EACA,0BAAAM,EACA,2BAAAW,EACA,gCAAAC,EACA,sBAAAC,EACA,iBAAA1B,EACA,qBAAAkB,EACA,kBAAAC,CACF"}