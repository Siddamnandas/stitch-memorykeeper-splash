{"version":3,"file":"SyncStatusIndicator-CTV-JR_R.js","sources":["../../src/lib/syncService.ts","../../src/lib/backgroundSyncManager.ts","../../src/hooks/useDataSync.ts","../../src/components/SyncStatusIndicator.tsx"],"sourcesContent":["import { supabase, isSupabaseConfigured } from './supabaseClient';\nimport {\n  getAllMemories,\n  getUnsyncedMemories,\n  saveProfile,\n  getProfile,\n  markMemoriesAsSynced,\n  markProfileAsSynced,\n  addSingleMemory,\n  OfflineMemory,\n  OfflineProfile\n} from './indexedDBService';\nimport { getMemories, getUserProfile, type Memory } from './dataService';\nimport { isRateLimited, getRemainingSyncAttempts } from './inputSanitizer';\n\ntype SafeSupabaseClient = NonNullable<typeof supabase>;\n\ntype SyncManager = {\n  register(_tag: string): Promise<void>;\n};\n\ntype SyncCapableRegistration = ServiceWorkerRegistration & {\n  sync: SyncManager;\n};\n\nconst hasBackgroundSync = (registration: ServiceWorkerRegistration): registration is SyncCapableRegistration => {\n  return typeof (registration as Partial<SyncCapableRegistration>).sync !== 'undefined';\n};\n\nexport interface SyncResult {\n  success: boolean;\n  uploadedCount: number;\n  downloadedCount: number;\n  conflictsResolved: number;\n  errors: string[];\n}\n\nexport interface SyncStatus {\n  isOnline: boolean;\n  lastSyncTime: number | null;\n  pendingChanges: number;\n  status: 'idle' | 'syncing' | 'error' | 'offline';\n}\n\n/**\n * Sync data between IndexedDB and Supabase\n * Handles bidirectional synchronization with conflict resolution\n * Enhanced with Workbox Background Sync support\n */\nexport const syncData = async (userId: string): Promise<SyncResult> => {\n  const result: SyncResult = {\n    success: false,\n    uploadedCount: 0,\n    downloadedCount: 0,\n    conflictsResolved: 0,\n    errors: []\n  };\n\n  if (!isSupabaseConfigured) {\n    result.success = true;\n    return result;\n  }\n\n  if (!userId) {\n    result.errors.push('User ID required for sync');\n    return result;\n  }\n\n  try {\n    // Step 1: Upload local changes to Supabase\n    const unsyncedMemories = await getUnsyncedMemories();\n\n    for (const memory of unsyncedMemories) {\n      try {\n        // Convert IndexedDB format to Supabase format\n        const supabaseMemory: Omit<Memory, 'id' | 'created_at'> = {\n          user_id: userId,\n          prompt: memory.prompt,\n          response: memory.response,\n          date: memory.date,\n          type: memory.type,\n          tags: memory.tags\n        };\n\n        const { error } = await (supabase as SafeSupabaseClient)\n          .from('memories')\n          .insert([supabaseMemory])\n          .select()\n          .single();\n\n        if (error) {\n          // Handle potential conflicts (duplicate entries)\n          if (error.code === '23505') { // Unique constraint violation\n            // Mark as synced since it already exists in cloud\n            await markMemoriesAsSynced([memory.id]);\n            result.conflictsResolved++;\n          } else {\n            result.errors.push(`Failed to upload memory \"${memory.prompt}\": ${error.message}`);\n            continue;\n          }\n        } else {\n          // Successfully uploaded, mark as synced\n          await markMemoriesAsSynced([memory.id]);\n          result.uploadedCount++;\n        }\n      } catch (error: any) {\n        result.errors.push(`Error uploading memory \"${memory.prompt}\": ${error.message}`);\n      }\n    }\n\n    // Step 2: Download new data from Supabase\n    try {\n      const { data: remoteMemories, error: fetchError } = await getMemories(userId);\n\n      if (fetchError) {\n        result.errors.push(`Failed to fetch remote memories: ${fetchError.message}`);\n      } else if (remoteMemories) {\n        // Get local memories for comparison\n        const localMemories = await getAllMemories();\n\n        // Find memories that exist remotely but not locally\n        const localIds = new Set(localMemories.map(m => m.id));\n\n        const newRemoteMemories = remoteMemories.filter(m => m.id && !localIds.has(m.id));\n\n        // Download new memories to local storage\n        for (const memory of newRemoteMemories) {\n          const offlineMemory: Omit<OfflineMemory, 'createdAt' | 'updatedAt'> = {\n            id: memory.id || `remote-${Date.now()}-${Math.random()}`,\n            userId: userId,\n            prompt: memory.prompt,\n            response: memory.response,\n            date: memory.date,\n            type: memory.type,\n            tags: memory.tags,\n            synced: true\n          };\n\n          const success = await addSingleMemory(offlineMemory);\n          if (success) {\n            result.downloadedCount++;\n          } else {\n            result.errors.push(`Failed to store memory \"${memory.prompt}\" locally`);\n          }\n        }\n      }\n    } catch (error: any) {\n      result.errors.push(`Error downloading memories: ${error.message}`);\n    }\n\n    // Step 3: Sync user profile\n    try {\n      const { data: remoteProfile, error: profileError } = await getUserProfile(userId);\n\n      if (!profileError && remoteProfile) {\n        // Update local profile with remote data if needed\n        const profileData: Omit<OfflineProfile, 'createdAt' | 'updatedAt'> = {\n          id: 'default',\n          userId: userId,\n          fullName: remoteProfile.full_name || undefined,\n          avatarUrl: remoteProfile.avatar_url || undefined,\n          memoryStrength: remoteProfile.memory_strength || 0,\n          synced: true\n        };\n\n        await saveProfile(profileData);\n        await markProfileAsSynced();\n      }\n    } catch (error: any) {\n      result.errors.push(`Error syncing profile: ${error.message}`);\n    }\n\n    result.success = result.errors.length === 0;\n\n    // Update last sync time on successful sync\n    if (result.success) {\n      try {\n        localStorage.setItem('lastSyncTime', Date.now().toString());\n      } catch (error) {\n        console.warn('Could not update lastSyncTime in localStorage:', error);\n      }\n    }\n\n    return result;\n\n  } catch (error: any) {\n    result.errors.push(`Sync failed: ${error.message}`);\n    return result;\n  }\n};\n\n/**\n * Check if device is online\n */\nexport const isOnline = (): boolean => {\n  return navigator.onLine;\n};\n\n/**\n * Get current sync status\n */\nexport const getSyncStatus = async (_userId: string): Promise<SyncStatus> => {\n  const unsyncedMemories = await getUnsyncedMemories();\n  const localProfile = await getProfile();\n\n  // Get last sync time from localStorage\n  let lastSyncTime: number | null = null;\n  try {\n    const stored = localStorage.getItem('lastSyncTime');\n    if (stored) {\n      lastSyncTime = parseInt(stored, 10);\n    }\n  } catch (error) {\n    console.warn('Could not read lastSyncTime from localStorage:', error);\n  }\n\n  return {\n    isOnline: isOnline(),\n    lastSyncTime: lastSyncTime,\n    pendingChanges: unsyncedMemories.length + (localProfile && !localProfile.synced ? 1 : 0),\n    status: isOnline() ? 'idle' : 'offline'\n  };\n};\n\n/**\n * Force a manual sync with rate limiting\n */\nexport const forceSync = async (userId: string): Promise<SyncResult> => {\n  if (!isSupabaseConfigured) {\n    return {\n      success: true,\n      uploadedCount: 0,\n      downloadedCount: 0,\n      conflictsResolved: 0,\n      errors: []\n    };\n  }\n  // Rate limiting: max 10 syncs per minute per user\n  if (isRateLimited(`sync_${userId}`, 10, 60000)) {\n    const remaining = getRemainingSyncAttempts(userId);\n    return {\n      success: false,\n      uploadedCount: 0,\n      downloadedCount: 0,\n      conflictsResolved: 0,\n      errors: [`Rate limited. ${remaining} sync attempts remaining.`]\n    };\n  }\n\n  if (!isOnline()) {\n    return {\n      success: false,\n      uploadedCount: 0,\n      downloadedCount: 0,\n      conflictsResolved: 0,\n      errors: ['Device is offline. Cannot sync.']\n    };\n  }\n\n  // Update last sync time before starting\n  try {\n    localStorage.setItem('lastSyncTime', Date.now().toString());\n  } catch (error) {\n    console.warn('Could not update lastSyncTime in localStorage:', error);\n  }\n\n  return await syncData(userId);\n};\n\n/**\n * Background sync when coming back online\n */\nexport const setupBackgroundSync = (userId: string, onSyncComplete?: (result: SyncResult) => void) => {\n  if (!isSupabaseConfigured) {\n    return () => undefined;\n  }\n  const handleOnline = async () => {\n    console.log('Device came back online, starting background sync...');\n    try {\n      const result = await syncData(userId);\n      onSyncComplete?.(result);\n    } catch (error) {\n      console.error('Background sync failed:', error);\n    }\n  };\n\n  window.addEventListener('online', handleOnline);\n\n  // Return cleanup function\n  return () => {\n    window.removeEventListener('online', handleOnline);\n  };\n};\n\n/**\n * Queue sync operation for background processing using Workbox\n */\nexport const queueBackgroundSync = async (userId: string): Promise<boolean> => {\n  if (!isSupabaseConfigured) {\n    return true;\n  }\n  try {\n    // Try to use Workbox background sync if available\n    if ('serviceWorker' in navigator) {\n      const registration = await navigator.serviceWorker.ready;\n      if (hasBackgroundSync(registration)) {\n        await registration.sync.register('background-sync');\n        return true;\n      }\n    }\n    \n    // Fallback to immediate sync\n    await syncData(userId);\n    return true;\n  } catch (error: unknown) {\n    console.error('Failed to queue background sync:', error);\n    return false;\n  }\n};\n\n// Export the sync service object\nexport const syncService = {\n  syncData,\n  isOnline,\n  getSyncStatus,\n  forceSync,\n  setupBackgroundSync,\n  queueBackgroundSync\n};\n","import { syncData } from './syncService';\nimport { getUnsyncedMemories, getProfile } from './indexedDBService';\nimport { isSupabaseConfigured } from './supabaseClient';\n\ntype SyncManager = {\n  register(tag: string): Promise<void>;\n};\n\ntype SyncCapableRegistration = ServiceWorkerRegistration & {\n  sync: SyncManager;\n};\n\nconst hasBackgroundSync = (registration: ServiceWorkerRegistration): registration is SyncCapableRegistration => {\n  return typeof (registration as Partial<SyncCapableRegistration>).sync !== 'undefined';\n};\n\n/**\n * Background Sync Manager\n * Handles automatic synchronization between IndexedDB and Supabase\n * with intelligent retry mechanisms and offline detection\n * Integrates with Workbox Background Sync for enhanced offline capabilities\n */\n\nclass BackgroundSyncManager {\n  private syncInterval: number | null = null;\n  private retryTimeout: number | null = null;\n  private isSyncing: boolean = false;\n  private retryCount: number = 0;\n  private maxRetries: number = 3;\n  private baseRetryDelay: number = 5000; // 5 seconds\n  private syncIntervalMs: number = 300000; // 5 minutes\n  private userId: string | null = null;\n  private isOnline: boolean = navigator.onLine;\n  private listeners: Array<(status: SyncStatus) => void> = [];\n  private lastPendingChanges: number = 0;\n  private workboxSyncRegistered: boolean = false;\n\n  constructor() {\n    // Monitor online/offline status\n    window.addEventListener('online', this.handleOnline.bind(this));\n    window.addEventListener('offline', this.handleOffline.bind(this));\n    \n    // Register service worker for background sync\n    this.registerServiceWorker();\n  }\n\n  /**\n   * Register service worker for enhanced background sync capabilities\n   */\n  private async registerServiceWorker(): Promise<void> {\n    if (import.meta.env.DEV) {\n      console.log('Skipping service worker registration in development');\n      return;\n    }\n\n    if ('serviceWorker' in navigator) {\n      try {\n        const registration = await navigator.serviceWorker.register('/sw.js');\n        console.log('Service worker registered successfully');\n\n        // Register background sync\n        if (hasBackgroundSync(registration)) {\n          try {\n            await registration.sync.register('background-sync');\n            console.log('Background sync registered');\n            this.workboxSyncRegistered = true;\n          } catch (error: unknown) {\n            console.error('Failed to register background sync:', error);\n          }\n        }\n      } catch (error) {\n        console.error('Service worker registration failed:', error);\n      }\n    }\n  }\n\n  /**\n   * Initialize the background sync manager with user ID\n   */\n  public init(userId: string): void {\n    if (!isSupabaseConfigured) {\n      console.log('Background sync not initialised: Supabase is not configured.');\n      return;\n    }\n    this.userId = userId;\n    \n    // Clear any existing intervals\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n    }\n    \n    // Start periodic sync\n    this.syncInterval = window.setInterval(this.sync.bind(this), this.syncIntervalMs);\n    \n    // Initial sync\n    this.sync();\n  }\n\n  /**\n   * Clean up resources\n   */\n  public destroy(): void {\n    if (this.syncInterval) {\n      clearInterval(this.syncInterval);\n      this.syncInterval = null;\n    }\n    \n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n    \n    this.listeners = [];\n  }\n\n  /**\n   * Add a listener for sync status updates\n   */\n  public addListener(listener: (status: SyncStatus) => void): void {\n    this.listeners.push(listener);\n  }\n\n  /**\n   * Remove a listener\n   */\n  public removeListener(listener: (status: SyncStatus) => void): void {\n    const index = this.listeners.indexOf(listener);\n    if (index > -1) {\n      this.listeners.splice(index, 1);\n    }\n  }\n\n  /**\n   * Notify all listeners of status change\n   */\n  private notifyListeners(status: SyncStatus): void {\n    this.listeners.forEach(listener => listener(status));\n  }\n\n  /**\n   * Handle online event\n   */\n  private handleOnline(): void {\n    if (!isSupabaseConfigured) {\n      return;\n    }\n    this.isOnline = true;\n    console.log('Device is online, triggering sync');\n    this.sync();\n    \n    // Trigger Workbox background sync if available\n    if (this.workboxSyncRegistered) {\n      navigator.serviceWorker.ready\n        .then(async (registration) => {\n          if (hasBackgroundSync(registration)) {\n            try {\n              await registration.sync.register('background-sync');\n            } catch (error: unknown) {\n              console.error('Failed to trigger background sync:', error);\n            }\n          }\n        })\n        .catch((error: unknown) => {\n          console.error('Failed to obtain service worker registration:', error);\n        });\n    }\n  }\n\n  /**\n   * Handle offline event\n   */\n  private handleOffline(): void {\n    this.isOnline = false;\n    console.log('Device is offline, pausing sync');\n    this.notifyListeners({\n      isOnline: false,\n      lastSyncTime: this.getLastSyncTime(),\n      pendingChanges: this.lastPendingChanges,\n      status: 'offline'\n    });\n  }\n\n  /**\n   * Get the last sync time from localStorage\n   */\n  private getLastSyncTime(): number | null {\n    try {\n      const stored = localStorage.getItem('lastSyncTime');\n      return stored ? parseInt(stored, 10) : null;\n    } catch (error) {\n      console.warn('Could not read lastSyncTime from localStorage:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Update the number of pending changes\n   */\n  private async updatePendingChanges(): Promise<void> {\n    try {\n      const unsyncedMemories = await getUnsyncedMemories();\n      const localProfile = await getProfile();\n      \n      this.lastPendingChanges = unsyncedMemories.length + (localProfile && !localProfile.synced ? 1 : 0);\n    } catch (error) {\n      console.warn('Could not get pending changes count:', error);\n    }\n  }\n\n  /**\n   * Main sync function\n   */\n  public async sync(): Promise<void> {\n    if (!isSupabaseConfigured) {\n      this.notifyListeners({\n        isOnline: this.isOnline,\n        lastSyncTime: this.getLastSyncTime(),\n        pendingChanges: this.lastPendingChanges,\n        status: this.isOnline ? 'idle' : 'offline'\n      });\n      return;\n    }\n    // Don't sync if already syncing or offline\n    if (this.isSyncing || !this.isOnline || !this.userId) {\n      return;\n    }\n\n    this.isSyncing = true;\n    \n    // Update pending changes count\n    await this.updatePendingChanges();\n    \n    this.notifyListeners({\n      isOnline: true,\n      lastSyncTime: this.getLastSyncTime(),\n      pendingChanges: this.lastPendingChanges,\n      status: 'syncing'\n    });\n\n    try {\n      const result = await syncData(this.userId);\n      \n      if (result.success) {\n        this.retryCount = 0; // Reset retry count on success\n        \n        // Update last sync time\n        try {\n          localStorage.setItem('lastSyncTime', Date.now().toString());\n        } catch (error) {\n          console.warn('Could not update lastSyncTime in localStorage:', error);\n        }\n        \n        // Update pending changes after successful sync\n        await this.updatePendingChanges();\n        \n        this.notifyListeners({\n          isOnline: true,\n          lastSyncTime: Date.now(),\n          pendingChanges: this.lastPendingChanges,\n          status: 'idle'\n        });\n      } else {\n        console.error('Sync failed:', result.errors);\n        this.handleSyncError();\n      }\n    } catch (error) {\n      console.error('Sync error:', error);\n      this.handleSyncError();\n    } finally {\n      this.isSyncing = false;\n    }\n  }\n\n  /**\n   * Handle sync errors with exponential backoff\n   */\n  private handleSyncError(): void {\n    this.retryCount++;\n    \n    if (this.retryCount <= this.maxRetries) {\n      // Exponential backoff: 5s, 10s, 20s, etc.\n      const delay = this.baseRetryDelay * Math.pow(2, this.retryCount - 1);\n      \n      this.notifyListeners({\n        isOnline: true,\n        lastSyncTime: this.getLastSyncTime(),\n        pendingChanges: this.lastPendingChanges,\n        status: 'error'\n      });\n      \n      console.log(`Sync failed, retrying in ${delay}ms (attempt ${this.retryCount}/${this.maxRetries})`);\n      \n      if (this.retryTimeout) {\n        clearTimeout(this.retryTimeout);\n      }\n      \n      this.retryTimeout = window.setTimeout(() => {\n        this.sync();\n      }, delay);\n    } else {\n      // Max retries reached\n      this.retryCount = 0;\n      this.notifyListeners({\n        isOnline: true,\n        lastSyncTime: this.getLastSyncTime(),\n        pendingChanges: this.lastPendingChanges,\n        status: 'error'\n      });\n      \n      console.error('Max sync retries reached, giving up until next interval');\n    }\n  }\n\n  /**\n   * Force immediate sync\n   */\n  public async forceSync(): Promise<void> {\n    if (!isSupabaseConfigured) {\n      return;\n    }\n    // Clear any pending retries\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n    \n    this.retryCount = 0;\n    await this.sync();\n  }\n  \n  /**\n   * Queue a sync request for background processing\n   */\n  public async queueSync(): Promise<void> {\n    if (!isSupabaseConfigured) {\n      return;\n    }\n    if (this.workboxSyncRegistered) {\n      // Use Workbox background sync when available\n      navigator.serviceWorker.ready\n        .then(async (registration) => {\n          if (hasBackgroundSync(registration)) {\n            try {\n              await registration.sync.register('background-sync');\n            } catch (error: unknown) {\n              console.error('Failed to queue background sync:', error);\n              await this.sync();\n            }\n          } else {\n            await this.sync();\n          }\n        })\n        .catch((error: unknown) => {\n          console.error('Failed to obtain service worker registration for queue:', error);\n          this.sync();\n        });\n    } else {\n      // Fallback to regular sync\n      this.sync();\n    }\n  }\n}\n\n// Define the sync status interface\nexport interface SyncStatus {\n  isOnline: boolean;\n  lastSyncTime: number | null;\n  pendingChanges: number;\n  status: 'idle' | 'syncing' | 'error' | 'offline';\n}\n\n// Export singleton instance\nexport const backgroundSyncManager = new BackgroundSyncManager();\n","import { useEffect, useCallback, useRef } from 'react';\nimport { useAuth } from '../lib/AuthContext';\nimport { useAppState } from '../lib/AppStateContext';\nimport { syncData, getSyncStatus, queueBackgroundSync } from '../lib/syncService';\nimport { isRateLimited } from '../lib/inputSanitizer';\nimport { backgroundSyncManager, SyncStatus } from '../lib/backgroundSyncManager';\nimport { isSupabaseConfigured } from '../lib/supabaseClient';\n\n/**\n * Custom hook for handling data synchronization between local storage and Supabase\n * Enhanced with Workbox Background Sync support for improved offline capabilities\n */\nexport const useDataSync = () => {\n  const { user } = useAuth();\n  const { state: appState, dispatch } = useAppState();\n  const syncIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const isInitializedRef = useRef(false);\n\n  /**\n   * Perform manual sync\n   */\n  const manualSync = useCallback(async () => {\n    if (!user?.id || !isSupabaseConfigured) return;\n\n    // Rate limiting: max 5 manual syncs per minute\n    if (isRateLimited(`manual_sync_${user.id}`, 5, 60000)) {\n      console.warn('Manual sync rate limited');\n      return;\n    }\n\n    try {\n      dispatch({ type: 'SET_SYNC_STATUS', payload: 'syncing' });\n      const result = await syncData(user.id);\n      \n      if (result.success) {\n        dispatch({ type: 'SET_SYNC_STATUS', payload: 'idle' });\n        dispatch({ type: 'SET_LAST_SYNC_TIME', payload: Date.now() });\n        \n        // Update pending changes count\n        const status = await getSyncStatus(user.id);\n        dispatch({ type: 'SET_PENDING_CHANGES', payload: status.pendingChanges });\n      } else {\n        dispatch({ type: 'SET_SYNC_STATUS', payload: 'error' });\n        console.error('Manual sync failed:', result.errors);\n      }\n    } catch (error) {\n      dispatch({ type: 'SET_SYNC_STATUS', payload: 'error' });\n      console.error('Manual sync error:', error);\n    }\n  }, [user?.id, dispatch]);\n\n  /**\n   * Check current sync status\n   */\n  const checkSyncStatus = useCallback(async () => {\n    if (!user?.id || !isSupabaseConfigured) return;\n\n    try {\n      const status = await getSyncStatus(user.id);\n      dispatch({ type: 'SET_ONLINE_STATUS', payload: status.isOnline });\n      dispatch({ type: 'SET_SYNC_STATUS', payload: status.status });\n      if (status.lastSyncTime) {\n        dispatch({ type: 'SET_LAST_SYNC_TIME', payload: status.lastSyncTime });\n      }\n      dispatch({ type: 'SET_PENDING_CHANGES', payload: status.pendingChanges });\n    } catch (error) {\n      console.error('Failed to check sync status:', error);\n    }\n  }, [user?.id, dispatch]);\n\n  /**\n   * Queue sync for background processing\n   */\n  const queueSync = useCallback(async () => {\n    if (!user?.id || !isSupabaseConfigured) return;\n\n    try {\n      const success = await queueBackgroundSync(user.id);\n      if (success) {\n        console.log('Sync queued for background processing');\n      } else {\n        console.warn('Failed to queue sync, falling back to manual sync');\n        await manualSync();\n      }\n    } catch (error) {\n      console.error('Failed to queue sync:', error);\n      await manualSync(); // Fallback to manual sync\n    }\n  }, [user?.id, manualSync]);\n\n  // Initialize sync manager and set up listeners\n  useEffect(() => {\n    if (!user?.id || !isSupabaseConfigured || isInitializedRef.current) return;\n    \n    isInitializedRef.current = true;\n\n    // Initialize the background sync manager\n    backgroundSyncManager.init(user.id);\n    \n    // Listen for sync status updates\n    const handleSyncStatus = (status: SyncStatus) => {\n      dispatch({ type: 'SET_ONLINE_STATUS', payload: status.isOnline });\n      dispatch({ type: 'SET_SYNC_STATUS', payload: status.status });\n      if (status.lastSyncTime) {\n        dispatch({ type: 'SET_LAST_SYNC_TIME', payload: status.lastSyncTime });\n      }\n      dispatch({ type: 'SET_PENDING_CHANGES', payload: status.pendingChanges });\n    };\n    \n    backgroundSyncManager.addListener(handleSyncStatus);\n\n    // Check initial sync status\n    checkSyncStatus();\n\n    // Set up periodic sync every 5 minutes when online (fallback)\n    syncIntervalRef.current = setInterval(() => {\n      if (navigator.onLine && appState.syncStatus !== 'syncing') {\n        manualSync();\n      }\n    }, 5 * 60 * 1000); // 5 minutes\n\n    // Listen for messages from service worker\n    const handleMessage = (event: MessageEvent) => {\n      if (event.data && event.data.type === 'SYNC_COMPLETE') {\n        console.log('Background sync completed via service worker');\n        checkSyncStatus();\n      }\n    };\n    \n    navigator.serviceWorker?.addEventListener('message', handleMessage);\n\n    // Cleanup\n    return () => {\n      if (syncIntervalRef.current) {\n        clearInterval(syncIntervalRef.current);\n      }\n      backgroundSyncManager.removeListener(handleSyncStatus);\n      navigator.serviceWorker?.removeEventListener('message', handleMessage);\n      isInitializedRef.current = false;\n    };\n  }, [user?.id, manualSync, checkSyncStatus, appState.syncStatus, dispatch]);\n\n  return {\n    isOnline: appState.isOnline,\n    syncStatus: appState.syncStatus,\n    lastSyncTime: appState.lastSyncTime,\n    pendingChanges: appState.pendingChanges,\n    manualSync,\n    checkSyncStatus,\n    queueSync,\n    forceSync: backgroundSyncManager.forceSync.bind(backgroundSyncManager)\n  };\n};\n","import { useState, useEffect, useContext, useCallback, useMemo, useRef } from 'react';\nimport React from 'react';\nimport { useDataSync } from '../hooks/useDataSync';\nimport { Wifi, WifiOff, RefreshCw, CheckCircle, AlertCircle, CloudOff, Clock } from 'lucide-react';\n\nconst SyncStatusIndicator: React.FC = () => {\n  const { isOnline, syncStatus, lastSyncTime, pendingChanges, forceSync, queueSync } = useDataSync();\n\n  const formatLastSyncTime = (timestamp: number | null): string => {\n    if (!timestamp) return 'Never';\n    \n    const now = Date.now();\n    const diffMs = now - timestamp;\n    const diffMinutes = Math.floor(diffMs / 60000);\n    const diffHours = Math.floor(diffMs / 3600000);\n    const diffDays = Math.floor(diffMs / 86400000);\n    \n    if (diffMinutes < 1) return 'Just now';\n    if (diffMinutes < 60) return `${diffMinutes}m ago`;\n    if (diffHours < 24) return `${diffHours}h ago`;\n    return `${diffDays}d ago`;\n  };\n\n  const getStatusIcon = () => {\n    if (!isOnline) {\n      return <WifiOff className=\"w-4 h-4 text-gray-500\" />;\n    }\n    \n    switch (syncStatus) {\n      case 'syncing':\n        return <RefreshCw className=\"w-4 h-4 text-blue-500 animate-spin\" />;\n      case 'error':\n        return <AlertCircle className=\"w-4 h-4 text-red-500\" />;\n      case 'idle':\n        return <CheckCircle className=\"w-4 h-4 text-green-500\" />;\n      default:\n        return <Wifi className=\"w-4 h-4 text-gray-500\" />;\n    }\n  };\n\n  const getStatusText = () => {\n    if (!isOnline) {\n      return 'Offline';\n    }\n    \n    switch (syncStatus) {\n      case 'syncing':\n        return 'Syncing...';\n      case 'error':\n        return 'Sync error';\n      case 'idle':\n        return 'Synced';\n      default:\n        return 'Online';\n    }\n  };\n\n  const getStatusColor = () => {\n    if (!isOnline) {\n      return 'text-gray-500';\n    }\n    \n    switch (syncStatus) {\n      case 'syncing':\n        return 'text-blue-500';\n      case 'error':\n        return 'text-red-500';\n      case 'idle':\n        return 'text-green-500';\n      default:\n        return 'text-gray-500';\n    }\n  };\n\n  return (\n    <div className=\"flex items-center gap-2 text-sm\">\n      <div\n        className=\"flex items-center gap-1\"\n        aria-live=\"polite\"\n        role=\"status\"\n      >\n        {getStatusIcon()}\n        <span className={getStatusColor()}>{getStatusText()}</span>\n      </div>\n      \n      {lastSyncTime && (\n        <span className=\"text-gray-500\">\n          {formatLastSyncTime(lastSyncTime)}\n        </span>\n      )}\n      \n      {pendingChanges > 0 && (\n        <span className=\"bg-orange-100 text-orange-800 px-2 py-1 rounded-full text-xs\">\n          {pendingChanges} pending\n        </span>\n      )}\n      \n      {!isOnline && (\n        <button\n          onClick={queueSync}\n          className=\"flex items-center gap-1 text-xs text-blue-600 hover:text-blue-800\"\n          title=\"Queue for sync when online\"\n        >\n          <Clock className=\"w-3 h-3\" />\n          Queue\n        </button>\n      )}\n      \n      {isOnline && (\n        <button\n          onClick={forceSync}\n          className=\"flex items-center gap-1 text-xs text-blue-600 hover:text-blue-800\"\n          title=\"Sync now\"\n        >\n          <RefreshCw className=\"w-3 h-3\" />\n          Sync\n        </button>\n      )}\n    </div>\n  );\n};\n\nexport default SyncStatusIndicator;\n"],"names":["hasBackgroundSync","registration","syncData","userId","result","isSupabaseConfigured","unsyncedMemories","getUnsyncedMemories","memory","supabaseMemory","error","supabase","markMemoriesAsSynced","remoteMemories","fetchError","getMemories","localMemories","getAllMemories","localIds","m","newRemoteMemories","offlineMemory","addSingleMemory","remoteProfile","profileError","getUserProfile","profileData","saveProfile","markProfileAsSynced","isOnline","getSyncStatus","_userId","localProfile","getProfile","lastSyncTime","stored","queueBackgroundSync","BackgroundSyncManager","__publicField","listener","index","status","delay","backgroundSyncManager","useDataSync","user","useAuth","appState","dispatch","useAppState","syncIntervalRef","useRef","isInitializedRef","manualSync","useCallback","isRateLimited","checkSyncStatus","queueSync","useEffect","handleSyncStatus","handleMessage","event","_a","SyncStatusIndicator","syncStatus","pendingChanges","forceSync","formatLastSyncTime","timestamp","diffMs","diffMinutes","diffHours","diffDays","getStatusIcon","jsx","WifiOff","RefreshCw","AlertCircle","CheckCircle","Wifi","getStatusText","getStatusColor","jsxs","Clock"],"mappings":"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"}